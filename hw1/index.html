<html>
	<head>
		<script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/MathJax.js?config=default'></script>
		<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600&display=swap" rel="stylesheet">
		<style>
			h1 {
				text-align: center;
			}

			.container {
				margin: 0 auto;
				padding: 60px 20%;
			}

			figure {
				text-align: center;
			}

			img {
				display: inline-block;
			}

			body {
				font-family: 'Inter', sans-serif;
			}
		</style>
	</head>
	<body>
		<div class="container">
		<h1>CS184/284A Spring 2025 Homework 1 Write-Up</h1>
		<div style="text-align: center;">Names: Mohammed Amin, Sean Tai </div>

		<br>

		Link to webpage: <a href="https://cs184.eecs.berkeley.edu/sp25">cs184.eecs.berkeley.edu/sp25</a>
		
		<br>

		Link to GitHub repository: <a href="https://cs184.eecs.berkeley.edu/sp25">cs184.eecs.berkeley.edu/sp25</a>
		<!--
		We've already added one heading per task, to make your write-up as navigable when grading. Please fit your write-up within these sections!
		-->

		<h2>Overview</h2>
		We implemented a full rasterization pipeline from basic triangle drawing to texture filtering with mipmaps. We started with single-color triangle rasterization, then added supersampling using a sample buffer and resolve step to reduce jagged edges, implemented transforms for scene edits, used barycentric interpolation for smooth color blending, and extended that to texture mapping with interpolated UVs. We also implemented nearest and bilinear sampling methods when drawing the textured rectangle, then added level sampling with mipmaps (<code>L_ZERO</code>, <code>L_NEAREST</code>, and linear level blending) using UV derivatives.
		This homework was definitely challenging at first, especially getting images to load correctly and getting comfortable with the C++ vector/math libraries. But step by step, we got much more comfortable with the workflow and the codebase. We also remember in Homework 0 we could not really tell the difference between the sampling methods when drawing the textured rectangle, and we did not clearly understand mipmaps when asked about them there. After implementing each method directly from the lecture slides in this homework, the differences are much clearer to us now, both visually and algorithmically.
		

		<h2>Task 1: Drawing Single-Color Triangles</h2>
		We first compute the bounding box that wraps the triangle from the minimum and maximum vertex coordinates and clamp it. We then iterate over each pixel inside this box and sample at the pixel center (x+0.5, y+0.5).

To determine if the sample is inside the triangle, we use the point in triangle test and formulas from class to evaluate 3 edges. A point is inside if all three edge values have the same sign. This handles both clockwise and counter-clockwise triangles and includes boundary pixels. If the point is inside, we call fill_pixel(x, y, color).

The algorithm only checks pixels within the triangle's bounding box and there's only 3 edge tests per pixel, so its runtime is proportional to the bounding box area, which matches the efficiency noted in the specification.

		<figure>
			<img src="screenshot_2-6_17-16-38.png" alt="Task 1 Screenshot" style="width:50%"/>
			<figcaption>Task 1 Screenshot</figcaption>
		</figure>

		<!-- <p>Here is an example 2x2 gridlike structure using an HTML table. Each <b>tr</b> is a row and each <b>td</b> is a column in that row. You might find this useful for framing and showing your result images in an organized fashion.</p>
		<div style="display: flex; flex-direction: column; align-items: center;">
			<table style="width: 100%; text-align: center; border-collapse: collapse;">
			  <tr>
				<td style="text-align: center;">
				  <img src="lion.jpg" width="400px"/>
				  <figcaption>Caption goes here.</figcaption>
				</td>
				<td style="text-align: center;">
				  <img src="lion.jpg" width="400px"/>
				  <figcaption>Caption goes here.</figcaption>
				</td>
			  </tr>
			  <tr>
				<td style="text-align: center;">
				  <img src="lion.jpg" width="400px"/>
				  <figcaption>Caption goes here.</figcaption>
				</td>
				<td style="text-align: center;">
				  <img src="lion.jpg" width="400px"/>
				  <figcaption>Caption goes here.</figcaption>
				</td>
			  </tr>
			</table>
		</div> -->
		
		<h2>Task 2: Antialiasing by Supersampling</h2>
		We treated each output pixel as a grid of \(\sqrt{\text{sample\_rate}} \times \sqrt{\text{sample\_rate}}\) subpixel samples stored in <code>sample_buffer</code>. We updated buffer management so the sample buffer always resizes correctly with framebuffer size and sampling rate changes, and we modified triangle rasterization to test coverage at each subpixel center rather than only at the pixel center. Covered subpixels are written into the sample buffer, while points and lines are handled by filling all subsamples of a pixel with the same color so they still render correctly. At the end of rendering, we resolve samples by averaging each pixel’s subsample colors and writing the result to the 8-bit RGB framebuffer. Supersampling is useful because edge pixels can represent partial triangle coverage instead of a binary inside/outside result, which reduces jagged edge. You can see this in action where the sample rates 1, 4, and 16 show progressively smoother boundaries, especially around thin corners and steep edges.
		<div style="display: flex; justify-content: center; gap: 20px; align-items: flex-start; flex-wrap: wrap;">
			<figure style="margin: 0; text-align: center;">
			  <img src="screenshot_2-9_17-20-47.png" alt="Task 2 sample rate 1" style="width: 320px;" />
			  <figcaption>Sample rate = 1</figcaption>
			</figure>
		  
			<figure style="margin: 0; text-align: center;">
			  <img src="screenshot_2-9_17-20-50.png" alt="Task 2 sample rate 4" style="width: 320px;" />
			  <figcaption>Sample rate = 4</figcaption>
			</figure>
		  
			<figure style="margin: 0; text-align: center;">
			  <img src="screenshot_2-9_17-20-53.png" alt="Task 2 sample rate 16" style="width: 320px;" />
			  <figcaption>Sample rate = 16</figcaption>
			</figure>
		  </div>
		  

		<h2>Task 3: Transforms</h2>
		We modified the robot mannequin to make both arms wave by rotating the last segment of each arm 90 degrees and applying a small translation to align them properly.

		<figure>
			<img src="screenshot_2-9_16-51-55.png" alt="Task 3 Screenshot" style="width:50%"/>
			<figcaption>Robot with both arms waving</figcaption>
		</figure>

		<h2>Task 4: Barycentric coordinates</h2>
		Barycentric coordinates express any point inside a triangle as a weighted combination of the three vertices: \( V = \alpha V_A + \beta V_B + \gamma V_C \), where \( \alpha + \beta + \gamma = 1 \). Each weight tells you how close the point is to the corresponding vertex. When we assign a different color to each vertex (e.g. red, green, blue), the barycentric weights smoothly blend those colors across the triangle's interior, as shown below. They can be used to represent color, texture coords, etc.

		<figure>
			<img src="Screenshot%202026-02-12%20at%209.04.18%E2%80%AFPM.png" alt="Barycentric coordinate triangle" style="width:50%"/>
			<figcaption>A triangle with red, green, and blue vertices blended via barycentric interpolation</figcaption>
		</figure>

		Below is a screenshot of svg/basic/test7.svg rendered with default viewing parameters and sample rate 1. The color wheel is composed of many small triangles, each with vertex colors interpolated using barycentric coordinates, producing the smooth gradient.

		<figure>
			<img src="screenshot_2-9_18-45-12.png" alt="test7.svg color wheel" style="width:50%"/>
			<figcaption>test7.svg — color wheel rendered at sample rate 1</figcaption>
		</figure>

		<h2>Task 5: "Pixel sampling" for texture mapping</h2>
		Pixel sampling is the process of deciding what texture color to use when a rasterized sample lands at a continuous UV coordinate 
		that usually does not align exactly with a texel center. In my implementation, we first compute barycentric coordinates for each 
		covered sample point in rasterize_textured_triangle, use them to interpolate the sample’s UV, and then sample the texture at mip level 0. For the two sampling methods,
		nearest sampling maps UV to texel space, picks the closest texel index, and 
		returns that single texel color, which is fast but can look blocky and aliased. Bilinear sampling retrieves the four texels around the UV location 
		and interpolates them using the slide’s lerp steps (horizontal lerps with alpha, then vertical lerp with beta), producing smoother results with 
		slightly higher cost.


		<div style="display: flex; flex-direction: column; align-items: center;">
			<table style="width: 100%; text-align: center; border-collapse: collapse;">
			  <tr>
				<td style="text-align: center;">
				  <img src="screenshot_2-12_20-37-8.png" width="400px"/>
				  <figcaption>Nearest, 1 sample/pixel</figcaption>
				</td>
				<td style="text-align: center;">
				  <img src="screenshot_2-12_20-37-27.png" width="400px"/>
				  <figcaption>Nearest, 16 samples/pixel</figcaption>
				</td>
			  </tr>
			  <tr>
				<td style="text-align: center;">
				  <img src="screenshot_2-12_20-37-44.png" width="400px"/>
				  <figcaption>Bilinear, 1 sample/pixel</figcaption>
				</td>
				<td style="text-align: center;">
				  <img src="screenshot_2-12_20-37-59.png" width="400px"/>
				  <figcaption>Bilinear, 16 samples/pixel</figcaption>
				</td>
			  </tr>
			</table>
		</div>
		  


		  <br>
		We used test2.svg and compared the same area with the pixel inspector for all four settings. 
		In nearest + 1 sample, the zoom box looks very blocky and each texel edge is obvious. 
		In nearest + 16 samples, the triangle edges look a little cleaner, but the texture itself is still blocky. 
		In bilinear + 1 sample, the texture already looks smoother because nearby texels are blended instead of picking 
		just one texel. In bilinear + 16 samples, it looks the best overall becuase it has smooth texture colors and cleaner shape edges.

		The biggest difference between nearest and bilinear shows up in places with lots of tiny color changes 
		(like coastlines and grid lines in this map). Nearest jumps from one texel color to another, so it looks
		 harsh and pixelated. Bilinear mixes nearby texels, so the color changes are more gradual and the image looks more natural.






		 <h2>Task 6: "Level Sampling" with mipmaps for texture mapping</h2>
		 Level sampling decides which mipmap resolution to use before doing pixel sampling. Instead of always sampling from the full-resolution texture, we estimate how quickly UV changes across one screen pixel and use that to choose a mip level. We implemented this by filling <code>SampleParams</code> in <code>rasterize_textured_triangle</code> for each sample point: <code>sp.p_uv</code> at \((x,y)\), <code>sp.p_dx_uv</code> at \((x+1,y)\), and <code>sp.p_dy_uv</code> at \((x,y+1)\), plus <code>psm</code> and <code>lsm</code>. In <code>get_level</code>, we compute the UV differences, scale them by the base texture width/height, compute the footprint size \(L\), and return \(D=\log_2(L)\). We implemented the sample function which dispatches to the appropriate pixel sampling method (sample_nearest or sample_bilinear) at either level 0 (L_ZERO), the nearest mipmap level (L_NEAREST), or a linear blend between two adjacent mipmap levels (L_LINEAR) for trilinear filtering.
		 <br><br>
		 <b>Tradeoffs:</b> Pixel sampling is the cheapest, it requires no extra memory and only a small speed cost for bilinear, but its antialiasing power is limited to smoothing texel boundaries. Increasing the number of samples per pixel (supersampling) gives strong antialiasing, but multiplies memory and computation proportional with the sample rate. Level sampling (mipmaps) is a good in between, the precomputed mipmap chain costs only a bit more memory (around 1/3 as shown in discussion), adds minimal per-pixel overhead to select a level, and effectively reduces aliasing in minified regions where many texels map to one pixel.
		 <br><br>


		 We chose to use a image which is a level from Super Mario Bros mapped on a flat quad and captured the four required combinations below.

<div style="display: flex; flex-direction: column; align-items: center;">
  <table style="width: 100%; text-align: center; border-collapse: collapse;">
    <tr>
      <td style="text-align: center;">
        <img src="screenshot_2-16_22-29-56.png" width="400px"/>
        <figcaption>L_ZERO + P_NEAREST</figcaption>
      </td>
      <td style="text-align: center;">
        <img src="screenshot_2-16_22-30-3.png" width="400px"/>
        <figcaption>L_ZERO + P_LINEAR</figcaption>
      </td>
    </tr>
    <tr>
      <td style="text-align: center;">
        <img src="screenshot_2-16_22-30-19.png" width="400px"/>
        <figcaption>L_NEAREST + P_NEAREST</figcaption>
      </td>
      <td style="text-align: center;">
        <img src="screenshot_2-16_22-30-26.png" width="400px"/>
        <figcaption>L_NEAREST + P_LINEAR</figcaption>
      </td>
    </tr>
  </table>
</div>

<br>

In this view showing one of the floating coins, the nearest-level outputs match the level-zero outputs where <code>L_ZERO + P_NEAREST</code> and <code>L_NEAREST + P_NEAREST</code> look the same, and <code>L_ZERO + P_LINEAR</code> and <code>L_NEAREST + P_LINEAR</code> look the same. Nearest looks more blocky in the inspector, while bilinear gives smoother color transitions.

	</body>
</html>