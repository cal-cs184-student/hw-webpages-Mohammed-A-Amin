<html>
	<head>
		<script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/MathJax.js?config=default'></script>
		<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600&display=swap" rel="stylesheet">
		<style>
			h1 {
				text-align: center;
			}

			.container {
				margin: 0 auto;
				padding: 60px 20%;
			}

			figure {
				text-align: center;
			}

			img {
				display: inline-block;
			}

			body {
				font-family: 'Inter', sans-serif;
			}
		</style>
	</head>
	<body>
		<div class="container">
		<h1>CS184/284A Spring 2025 Homework 1 Write-Up</h1>
		<div style="text-align: center;">Names: </div>

		<br>

		Link to webpage: (TODO) <a href="https://cs184.eecs.berkeley.edu/sp25">cs184.eecs.berkeley.edu/sp25</a>
		
		<br>

		Link to GitHub repository: (TODO) <a href="https://cs184.eecs.berkeley.edu/sp25">cs184.eecs.berkeley.edu/sp25</a>

		<figure>
			<img src="lion.jpg" alt="Lion" style="width:50%"/>
			<figcaption>You can add images with captions!</figcaption>
		</figure>

		<!--
		We've already added one heading per task, to make your write-up as navigable when grading. Please fit your write-up within these sections!
		-->

		<h2>Overview</h2>
		Give a high-level overview of what you implemented in this homework. Think about what you've built as a whole. Share your thoughts on what interesting things you've learned from completing the homework.

		<h2>Task 1: Drawing Single-Color Triangles</h2>
		I first compute the bounding box that wraps the triangle from the minimum and maximum vertex coordinates and clamp it. I then iterate over each pixel inside this box and sample at the pixel center (x+0.5, y+0.5).

To determine if the sample is inside the triangle, I use the point in triangle test and formulas from class to evaluate 3 edges. A point is inside if all three edge values have the same sign. This handles both clockwise and counter-clockwise triangles and includes boundary pixels. If the point is inside, I call fill_pixel(x, y, color).

The algorithm only checks pixels within the triangle's bounding box and there's only 3 edge tests per pixel, so its runtime is proportional to the bounding box area, which matches the efficiency noted in the specification.

		<figure>
			<img src="screenshot_2-6_17-16-38.png" alt="Task 1 Screenshot" style="width:50%"/>
			<figcaption>Task 1 Screenshot</figcaption>
		</figure>

		<!-- <p>Here is an example 2x2 gridlike structure using an HTML table. Each <b>tr</b> is a row and each <b>td</b> is a column in that row. You might find this useful for framing and showing your result images in an organized fashion.</p>
		<div style="display: flex; flex-direction: column; align-items: center;">
			<table style="width: 100%; text-align: center; border-collapse: collapse;">
			  <tr>
				<td style="text-align: center;">
				  <img src="lion.jpg" width="400px"/>
				  <figcaption>Caption goes here.</figcaption>
				</td>
				<td style="text-align: center;">
				  <img src="lion.jpg" width="400px"/>
				  <figcaption>Caption goes here.</figcaption>
				</td>
			  </tr>
			  <tr>
				<td style="text-align: center;">
				  <img src="lion.jpg" width="400px"/>
				  <figcaption>Caption goes here.</figcaption>
				</td>
				<td style="text-align: center;">
				  <img src="lion.jpg" width="400px"/>
				  <figcaption>Caption goes here.</figcaption>
				</td>
			  </tr>
			</table>
		</div> -->
		
		<h2>Task 2: Antialiasing by Supersampling</h2>
		I treated each output pixel as a grid of \(\sqrt{\text{sample\_rate}} \times \sqrt{\text{sample\_rate}}\) subpixel samples stored in <code>sample_buffer</code>. I updated buffer management so the sample buffer always resizes correctly with framebuffer size and sampling rate changes, and I modified triangle rasterization to test coverage at each subpixel center rather than only at the pixel center. Covered subpixels are written into the sample buffer, while points and lines are handled by filling all subsamples of a pixel with the same color so they still render correctly. At the end of rendering, I resolve samples by averaging each pixel’s subsample colors and writing the result to the 8-bit RGB framebuffer. Supersampling is useful because edge pixels can represent partial triangle coverage instead of a binary inside/outside result, which reduces jagged edge. You can this in action where the sample rates 1, 4, and 16 show progressively smoother boundaries, especially around thin corners and steep edges.
		<div style="display: flex; justify-content: center; gap: 20px; align-items: flex-start; flex-wrap: wrap;">
			<figure style="margin: 0; text-align: center;">
			  <img src="screenshot_2-9_17-20-47.png" alt="Task 2 sample rate 1" style="width: 320px;" />
			  <figcaption>Sample rate = 1</figcaption>
			</figure>
		  
			<figure style="margin: 0; text-align: center;">
			  <img src="screenshot_2-9_17-20-50.png" alt="Task 2 sample rate 4" style="width: 320px;" />
			  <figcaption>Sample rate = 4</figcaption>
			</figure>
		  
			<figure style="margin: 0; text-align: center;">
			  <img src="screenshot_2-9_17-20-53.png" alt="Task 2 sample rate 16" style="width: 320px;" />
			  <figcaption>Sample rate = 16</figcaption>
			</figure>
		  </div>
		  

		<h2>Task 3: Transforms</h2>
		I modified the robot mannequin to make both arms wave by rotating the last segment of each arm 90 degrees and applying a small translation to align them properly.

		<figure>
			<img src="screenshot_2-9_16-51-55.png" alt="Task 3 Screenshot" style="width:50%"/>
			<figcaption>Robot with both arms waving</figcaption>
		</figure>

		<h2>Task 4: Barycentric coordinates</h2>
		Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.

		<h2>Task 5: "Pixel sampling" for texture mapping</h2>
		Pixel sampling is the process of deciding what texture color to use when a rasterized sample lands at a continuous UV coordinate 
		that usually does not align exactly with a texel center. In my implementation, I first compute barycentric coordinates for each 
		covered sample point in rasterize_textured_triangle, use them to interpolate the sample’s UV, and then sample the texture at mip level 0. For the two sampling methods,
		nearest sampling maps UV to texel space, picks the closest texel index, and 
		returns that single texel color, which is fast but can look blocky and aliased. Bilinear sampling retrieves the four texels around the UV location 
		and interpolates them using the slide’s lerp steps (horizontal lerps with alpha, then vertical lerp with beta), producing smoother results with 
		slightly higher cost.


		<div style="display: flex; justify-content: center; gap: 20px; flex-wrap: wrap; margin-top: 16px;">
			<figure style="margin: 0; text-align: center; width: 360px;">
			  <img src="screenshot_2-12_20-37-8.png" alt="Nearest sampling, 1 sample per pixel" style="width: 100%;" />
			  Nearest, 1 sample/pixel
			</figure>
		  
			<figure style="margin: 0; text-align: center; width: 360px;">
			  <img src="screenshot_2-12_20-37-27.png" alt="Nearest sampling, 16 samples per pixel" style="width: 100%;" />
			  Nearest, 16 samples/pixel
			</figure>
		  
			<figure style="margin: 0; text-align: center; width: 360px;">
			  <img src="screenshot_2-12_20-37-44.png" alt="Bilinear sampling, 1 sample per pixel" style="width: 100%;" />
			  Bilinear, 1 sample/pixel
			</figure>
		  
			<figure style="margin: 0; text-align: center; width: 360px;">
			  <img src="screenshot_2-12_20-37-59.png" alt="Bilinear sampling, 16 samples per pixel" style="width: 100%;" />
			  Bilinear, 16 samples/pixel
			</figure>
		  </div>
		  


		  <br>
		I used test2.svg and compared the same area with the pixel inspector for all four settings. 
		In nearest + 1 sample, the zoom box looks very blocky and each texel edge is obvious. 
		In nearest + 16 samples, the triangle edges look a little cleaner, but the texture itself is still blocky. 
		In bilinear + 1 sample, the texture already looks smoother because nearby texels are blended instead of picking 
		just one texel. In bilinear + 16 samples, it looks the best overall becuase it has smooth texture colors and cleaner shape edges.

		The biggest difference between nearest and bilinear shows up in places with lots of tiny color changes 
		(like coastlines and grid lines in this map). Nearest jumps from one texel color to another, so it looks
		 harsh and pixelated. Bilinear mixes nearby texels, so the color changes are more gradual and the image looks more natural.






		<h2>Task 6: "Level Sampling" with mipmaps for texture mapping</h2>
		Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.

		<h2>(Optional) Task 7: Extra Credit - Draw Something Creative!</h2>
		Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.

		<h2>Additional Notes (please remove)</h2>
		<ul>
			<li>You can also add code if you'd like as so: <code>code code code</code></li>
			<li>If you'd like to add math equations, 
				<ul>
					<li>You can write inline equations like so: \( a^2 + b^2 = c^2 \)</li>
					<li>You can write display equations like so: \[ a^2 + b^2 = c^2 \]</li>
				</ul>
			</li>
		</ul>
		</div>
	</body>
</html>